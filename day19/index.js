import process from 'process';
import { readInput, sortByNumberAsc } from '../utils/index.js';

const DEFAULT_BATCH_SIZE = 5;

// Reading args
const [solutionNumber, value, ...args] = process.argv.slice(2);
const batchSize = value ? parseInt(value) : DEFAULT_BATCH_SIZE;

(async function() {
    // Reading data
    const data = await readInput('input.txt');

    // Running solution
    return await solutions[solutionNumber](data, batchSize);
})();

////////////////////////////////////////////

const solutions = {
    '1': solution1,
    '2': solution2
};

////////////////////////////////////////////

async function solution1(data) {
    const lines = data.split('\n');
    const [molecule, replacementsMap] = readData(lines);

    const newMolecules = generateNewMolecules(molecule, replacementsMap);

    console.log('========================');
    console.log('Solution1: ', newMolecules.size);
    console.log('========================');
}

async function solution2(data, batchSize) {
    const lines = data.split('\n');
    const [targetMolecule, replacementsMap] = readData(lines);

    const reverseReplacementsMap = {};
    for(const [key, values] of Object.entries(replacementsMap)) {
        values.forEach(v => { reverseReplacementsMap[v] = [key]; });
    }

    const generatedMolecules = generateSourceMolecules(targetMolecule, reverseReplacementsMap, batchSize);
    console.log(generatedMolecules.size, 1);

    console.log('========================');
    console.log('Solution2: ', generatedMolecules.get(STARTING_ELEMENT));
    console.log('========================');
}

////////////////////////////////////////////

const STARTING_ELEMENT = 'e';

function readData(lines) {
    const molecule = lines.pop();
    lines.pop(); // Removing empty line

    const replacementsMap = {};
    lines.forEach(line => {
        const [input, output] = line.split(' => ');
        if(!replacementsMap[input]) {
            replacementsMap[input] = [];
        }

        replacementsMap[input].push(output);
    });

    return [molecule, replacementsMap];
}

function generateNewMolecules(molecule, replacementsMap) {
    const elements = Object.keys(replacementsMap);

    const newMolecules = new Set();
    for(let i = 0; i < molecule.length; ++i) {
        elements.forEach(e => {
            if(molecule.substr(i, e.length) === e) {
                for(const replacement of replacementsMap[e]) {
                    const newMolecule = molecule.substr(0, i) + replacement + molecule.substr(i + e.length);
                    newMolecules.add(newMolecule);
                }
            }
        });
    }

    return newMolecules;
}

/*
    Going from STARTING_ELEMENT to target molecule will not work since search space grow up way too fast !
    We can't prioritize new molecules to reduce search space since we can't know beforehand which ones will lead to target molecules...

    Since STARTING_ELEMENT is a terminal element which cannot be generated by any other rule, by going in reverse from target molecule,
    we are guaranty to end up with STARTING_ELEMENT eventually since each new generated molecules will be shorter or at least not bigger.

    Even if the search space is still too big, we can prioritize processing shortest molecules first, in small batch, to speed up the process,
    as long as the batch size is big enough to generate enough new molecules each step...

    Some benchmarks for various batchsizes:
        1       --> ???
        2       --> about 2 seconds
        5       --> about 2 to 3 seconds
        10      --> about 3 to 4 seconds
        100     --> about 16 seconds
        500     --> about 90 seconds
        1000    --> about 170 seconds

    TODO: Implements CYK algorithm for context-free grammar instead ???
*/
function generateSourceMolecules(targetMolecule, reverseReplacementsMap, batchSize) {
    const generatedMolecules = new Map([[targetMolecule, 0]]);
    const moleculesToProcess = {
        [targetMolecule.length]: { [targetMolecule]: 0 }
    };

    while(!generatedMolecules.has(STARTING_ELEMENT)) {
        // Always searching a limited batch of shortest molecules first
        const shortestLength = Object.keys(moleculesToProcess).filter(key => Object.keys(moleculesToProcess[key]).length > 0).sort(sortByNumberAsc)[0];
        const molecules = Object.keys(moleculesToProcess[shortestLength]).slice(0, batchSize);
        console.log(generatedMolecules.size, shortestLength);

        for(const molecule of molecules) {
            const nbSteps = generatedMolecules.get(molecule);
            delete moleculesToProcess[shortestLength][molecule];

            const newMolecules = generateNewMolecules(molecule, reverseReplacementsMap);
            if(newMolecules.has(STARTING_ELEMENT)) {
                generatedMolecules.set(STARTING_ELEMENT, nbSteps + 1);
                return generatedMolecules;
            }

            newMolecules.forEach(m => {
                if(generatedMolecules.has(m)) {
                    return; // Skipping already generated molecules
                }
                if(m.includes(STARTING_ELEMENT) && m !== STARTING_ELEMENT) {
                    return; // Skipping molecule with non generable starting element
                }

                generatedMolecules.set(m, nbSteps + 1);

                if(!moleculesToProcess[m.length]) {
                    moleculesToProcess[m.length] = {};
                }

                moleculesToProcess[m.length][m] = nbSteps + 1;
            });
        };
    }

    return generatedMolecules;
}